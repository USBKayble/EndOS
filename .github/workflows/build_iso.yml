name: Build EndOS ISO

on:
  push:
    tags:
      - 'v*'
    branches:
      - main
      - feature/live-iso
    paths:
      - 'RELEASE_NOTES.md'
      - '.github/workflows/build_iso.yml'
  workflow_dispatch:

jobs:
  build:
    runs-on: self-hosted
    permissions:
      contents: write
    container:
      image: archlinux:latest
      options: --privileged

    steps:
    - name: Install Archiso Tools
      run: |
        # Initialize keyring first
        pacman-key --init
        pacman-key --populate archlinux

        # Add Chaotic AUR to support AGS, swww, etc.
        pacman-key --recv-key 3056513887B78AEB --keyserver keyserver.ubuntu.com
        pacman-key --lsign-key 3056513887B78AEB
        pacman -U 'https://cdn-mirror.chaotic.cx/chaotic-aur/chaotic-keyring.pkg.tar.zst' 'https://cdn-mirror.chaotic.cx/chaotic-aur/chaotic-mirrorlist.pkg.tar.zst' --noconfirm

        # Enable Multilib (Critical for Steam, Wine, etc detection)
        sed -i "/\[multilib\]/,/Include/"'s/^#//' /etc/pacman.conf

        # Append to pacman.conf
        echo "" >> /etc/pacman.conf
        echo "[chaotic-aur]" >> /etc/pacman.conf
        echo "Include = /etc/pacman.d/chaotic-mirrorlist" >> /etc/pacman.conf

        # Update and Install Tools
        pacman -Sy --noconfirm archiso git grub syslinux dosfstools mtools wget unzip python base-devel

    - name: Checkout Code
      uses: actions/checkout@v4

    - name: Prepare ISO Files
      run: |
        # 1. Start with a clean official 'releng' profile
        cp -r /usr/share/archiso/configs/releng iso-build
        
        # 2. Inject ONLY our custom files into the standard profile
        # 2. Inject ALL custom files from our repo into the build profile
        # This includes .bash_profile, config.json, setup_arch.sh, dotfiles, and desktop shortcuts
        cp -a iso/airootfs/. iso-build/airootfs/

        # 2.05 CLONE DOTFILES
        # We clone the fresh dotfiles from the repo instead of relying on local files
        # First, ensure the target directory is clean (in case it was copied from local repo)
        rm -rf iso-build/airootfs/usr/share/endos/dots
        mkdir -p iso-build/airootfs/usr/share/endos/dots
        git clone --recursive --depth 1 https://github.com/end-4/dots-hyprland.git iso-build/airootfs/usr/share/endos/dots

        # 2.06 PREPARE BUILDER (For AUR)
        # Create a builder user because makepkg cannot run as root.
        useradd -m builder
        echo "builder ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers
        chmod 777 .

        # Install yay (pre-built bin from AUR)
        su builder -c "
            git clone https://aur.archlinux.org/yay-bin.git /tmp/yay-bin
            cd /tmp/yay-bin
            makepkg -si --noconfirm
        "

        # 2.06a IDENTIFY PACKAGES
        # We have two sources of packages:
        # 1. 'Dots' dependencies (from collect_packages.sh)
        # 2. 'Manual' list (iso/packages.x86_64) that contains user apps + drivers
        
        echo "Collecting all requested packages..."
        mkdir -p /tmp/pkg-processing
        
        # Get Dots packages
        bash util/collect_packages.sh iso-build/airootfs/usr/share/endos/dots > /tmp/pkg-processing/dots.txt
        
        # Get Manual packages (strip comments)
        sed '/^#/d; /^$/d' iso/packages.x86_64 > /tmp/pkg-processing/manual.txt
        
        # Combine
        cat /tmp/pkg-processing/dots.txt /tmp/pkg-processing/manual.txt | sort -u > /tmp/pkg-processing/all_requested.txt
        
        # Filter: Separate into AUR (to build) and Repo (to install directly)
        echo "Separating AUR vs Repo packages..."
        cat /tmp/pkg-processing/all_requested.txt | bash util/filter_aur.sh > aur_deps.txt
        
        echo "AUR Candidates:"
        cat aur_deps.txt
        
        # 2.06b BUILD AUR PACKAGES
        # Build them
        mkdir -p repo
        chown builder:builder repo
        
        echo "Building AUR packages..."
        
        # Check if we have AUR deps
        if [ -s aur_deps.txt ]; then
            su builder -c "
                mkdir -p /tmp/aur-build
                yay -S --noconfirm --builddir /tmp/aur-build \$(cat aur_deps.txt)
                
                # Find built packages and add to repo
                find /tmp/aur-build -name '*.pkg.tar.zst' -exec cp {} repo/ \;
                cd repo
                repo-add endos-local.db.tar.gz *.pkg.tar.zst
            "
        else
            echo "No AUR dependencies found."
            # Create empty repo to prevent pacman errors if configured
            su builder -c "
                cd repo
                repo-add endos-local.db.tar.gz
            "
        fi

        # 2.07 CONFIGURE LOCAL REPO
        # Add the local repo to mkarchiso's pacman.conf
        # We must use file:/// URL style for local repo in build container
        REPO_PATH="$(pwd)/repo"
        
        sed -i '1i[endos-local]\nSigLevel = Optional TrustAll\nServer = file://'"$REPO_PATH" iso-build/pacman.conf
        
        # 2.1 PATCH mkarchiso pacman.conf
        # The build tool uses this specific config file to resolve packages.
        # We must enable MULTILIB for 32-bit driver support (lib32-mesa, etc.)
        sed -i "/\[multilib\]/,/Include/"'s/^#//' iso-build/pacman.conf
        
        # We must add Chaotic AUR here so it can find AGS/swww.
        echo "" >> iso-build/pacman.conf
        echo "[chaotic-aur]" >> iso-build/pacman.conf
        echo "Include = /etc/pacman.d/chaotic-mirrorlist" >> iso-build/pacman.conf
        
        # 2.5 MERGE Package Lists
        # We use the FULL requested list. 
        # Since we've added the local repo, pacman will find both 'repo' pkgs and our built 'aur' pkgs.
        cp /tmp/pkg-processing/all_requested.txt iso-build/packages.x86_64
        
        # 2.5a RESOLVE CONFLICTS
        # 'releng' profile includes virtualbox-guest-utils-nox, but we want the full version (virtualbox-guest-utils) or none.
        # Since we removed vmware driver, we ensure no conflict.
        sed -i '/virtualbox-guest-utils-nox/d' iso-build/packages.x86_64
        
        # 2.6 VERIFICATION
        # Verify dotfiles were copied correctly
        if [ ! -d "iso-build/airootfs/usr/share/endos/dots" ]; then
            echo "ERROR: Dotfiles directory missing in build root!"
            exit 1
        fi
        
        # 3. Branding: Rename ISO to EndOS
        # We modify the official profiledef.sh in-place to avoid breaking boot modes.
        # We modify the official profiledef.sh in-place to avoid breaking boot modes.
        sed -i 's/iso_name="archlinux"/iso_name="EndOS"/' iso-build/profiledef.sh
        sed -i 's/iso_label="ARCH_$(date +%Y%m)"/iso_label="ENDOS_$(date +%Y%m)"/' iso-build/profiledef.sh
        sed -i 's/iso_publisher="Arch Linux <https:\/\/archlinux.org>"/iso_publisher="EndOS <https:\/\/github.com\/USBKayble\/EndOS>"/' iso-build/profiledef.sh
        sed -i 's/iso_application="Arch Linux Live\/Rescue CD"/iso_application="EndOS Live\/Rescue CD"/' iso-build/profiledef.sh

        # 4. Plymouth (Bootscreen) Configuration
        # Create a custom mkinitcpio.conf for the ISO (adding plymouth hook)
        # We start with standard archiso hooks and insert plymouth after udev
        cat > iso-build/airootfs/etc/mkinitcpio.conf <<EOF
        MODULES=()
        BINARIES=()
        FILES=()
        HOOKS=(base udev plymouth modconf kms block filesystems fsck)
        EOF
        
        # 4.1 BAKED-IN CONFIGURATION (Live User & Logs)
        
        # A. Create global log directory (777 permissions)
        mkdir -p iso-build/airootfs/log
        chmod 777 iso-build/airootfs/log
        
        # B. Setup 'setup' command symlink
        # Link /usr/local/bin/setup -> /root/setup_arch.sh
        mkdir -p iso-build/airootfs/usr/local/bin
        ln -sf /root/setup_arch.sh iso-build/airootfs/usr/local/bin/setup
        chmod +x iso-build/airootfs/root/setup_arch.sh
        
        # C. Configure /root (No Live User)
        # We are using root directly for the live session to simplify permissions and setup.
        
        # D. Pre-populate /root with dotfiles
        DOTS_SRC="iso-build/airootfs/usr/share/endos/dots"
        LIVE_HOME="iso-build/airootfs/root"
        SKEL_DIR="iso-build/airootfs/etc/skel"
        
        echo "Copying dotfiles from $DOTS_SRC/dots to $LIVE_HOME and $SKEL_DIR"
        
        # Create directories
        mkdir -p "$LIVE_HOME/.config" "$LIVE_HOME/.local"
        mkdir -p "$SKEL_DIR/.config" "$SKEL_DIR/.local"
        
        # Copy .config
        if [ -d "$DOTS_SRC/dots/.config" ]; then
            cp -a "$DOTS_SRC/dots/.config/." "$LIVE_HOME/.config/"
            cp -a "$DOTS_SRC/dots/.config/." "$SKEL_DIR/.config/"
        else
            echo "WARNING: dots/.config not found in $DOTS_SRC"
        fi
        
        # Copy .local
        if [ -d "$DOTS_SRC/dots/.local" ]; then
            cp -a "$DOTS_SRC/dots/.local/." "$LIVE_HOME/.local/"
            cp -a "$DOTS_SRC/dots/.local/." "$SKEL_DIR/.local/"
        else
            echo "WARNING: dots/.local not found in $DOTS_SRC"
        fi

        # 4.1a INSTALL PYTHON DEPENDENCIES (For Live User)
        # Quickshell requires specific python packages in a venv.
        echo "Installing Python dependencies for Live User..."
        
        # Ensure uv is installed on the runner
        pacman -S --noconfirm uv
        
        VENV_DIR="$LIVE_HOME/.local/state/quickshell/.venv"
        REQ_FILE="$DOTS_SRC/sdata/uv/requirements.txt"
        
        mkdir -p "$(dirname "$VENV_DIR")"
        
        # Use system python (Arch is rolling, usually latest)
        # We rely on uv to create the venv and install packages.
        # Note: We run this ON THE RUNNER, targeting the directory in the isolated FS.
        # This works because we are same arch (x86_64).
        export UV_NO_MODIFY_PATH=1
        uv venv "$VENV_DIR"
        
        # Install requirements
        if [ -f "$REQ_FILE" ]; then
            source "$VENV_DIR/bin/activate"
            uv pip install -r "$REQ_FILE"
            deactivate
        else
            echo "WARNING: requirements.txt not found at $REQ_FILE"
        fi
        
        # Copy root dotfiles (bashrc, etc if they exist in dots root)
        # Note: The repo structure usually has them in dots/ or dots/.config
        # We can copy loose files from dots/ if needed, but for now strict structure is safer.
        
        # Create README
        echo "Welcome to EndOS! Run 'setup' to install." > "$LIVE_HOME/README.txt"
        
        # Fix Ownership (Root is 0:0, which is default, but ensuring permissions)
        chown -R 0:0 "$LIVE_HOME"

        # 4.2 ENABLE SERVICES
        # We must manually enable systemd services by creating symlinks in the build root
        SERVICES_DIR="iso-build/airootfs/etc/systemd/system/multi-user.target.wants"
        mkdir -p "$SERVICES_DIR"
        
        # NetworkManager
        ln -sf /usr/lib/systemd/system/NetworkManager.service "$SERVICES_DIR/NetworkManager.service"
        
        # Bluetooth
        ln -sf /usr/lib/systemd/system/bluetooth.service "$SERVICES_DIR/bluetooth.service"
        
        # SSHD (Optional but useful for debugging)
        ln -sf /usr/lib/systemd/system/sshd.service "$SERVICES_DIR/sshd.service"
        
        # Patch syslinux (BIOS)
        find iso-build/syslinux -name "*.cfg" -exec sed -i 's/archisobasedir/splash quiet archisobasedir/g' {} +
        
        # Patch GRUB (UEFI)
        find iso-build/grub -name "grub.cfg" -exec sed -i 's/loglevel=3/loglevel=3 splash quiet/g' {} +

    - name: Build Arch ISO
      run: |
        mkdir -p output
        mkarchiso -v -w /tmp/archiso-work -o output iso-build

    - name: Read Release Notes
      id: release_notes
      run: |
        # Read the file content into a variable, handling newlines
        echo "notes<<EOF" >> $GITHUB_OUTPUT
        cat RELEASE_NOTES.md >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Rename ISO
      id: rename_iso
      run: |
        ISO_FILE=$(find output -name "*.iso")
        
        # Extract title from RELEASE_NOTES.md (remove '# ', replace space with '-')
        # Sanitize to alphanumeric, dashes, dots
        # Extract title from RELEASE_NOTES.md (find first line starting with '# ')
        RELEASE_TITLE=$(grep -m 1 "^# " RELEASE_NOTES.md | sed 's/^# //g' | tr -s ' ' '-')
        
        # Date string
        DATE_TAG=$(date +'%Y.%m.%d')
        
        NEW_NAME="${RELEASE_TITLE}-${DATE_TAG}.iso"
        
        # Rename original to target name
        mv "$ISO_FILE" "output/$NEW_NAME"
        echo "Renamed ISO to: $NEW_NAME"
        
        # Check size (GitHub Limit is 2GB = 2147483648 bytes)
        # We use strict 1900MB limit to be safe
        FILE_SIZE=$(stat -c%s "output/$NEW_NAME")
        MAX_SIZE=$(( 1900 * 1024 * 1024 ))
        
        if [ "$FILE_SIZE" -gt "$MAX_SIZE" ]; then
            echo "File size ($FILE_SIZE bytes) exceeds limit ($MAX_SIZE bytes). Splitting..."
            
            # Go to output dir to not include path in split filenames
            cwd=$(pwd)
            cd output
            
            # Split into chunks with numeric suffixes (.00, .01)
            # Use -- to prevent filename being interpreted as flags if it starts with dash
            split -b 1900M --numeric-suffixes=00 -- "$NEW_NAME" "$NEW_NAME."
            
            # Remove the original large file
            rm "$NEW_NAME"
            cd "$cwd"
            
            echo "iso_path=output/$NEW_NAME.*" >> $GITHUB_OUTPUT
        else
            echo "File size ($FILE_SIZE bytes) is within limits."
            echo "iso_path=output/$NEW_NAME" >> $GITHUB_OUTPUT
        fi

    - name: Release
      uses: softprops/action-gh-release@v1
      if: startsWith(github.ref, 'refs/tags/') || github.ref == 'refs/heads/main' || github.ref == 'refs/heads/feature/live-iso'
      with:
        files: |
          ${{ steps.rename_iso.outputs.iso_path }}
          setup_arch.sh
        name: EndOS Release ${{ github.run_number }}
        tag_name: v${{ github.run_number }}
        body: ${{ steps.release_notes.outputs.notes }}
        prerelease: ${{ github.ref == 'refs/heads/feature/live-iso' }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
